<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RoboTrail</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: system-ui, sans-serif;
    background: #0f0f1a;
    color: #e0e0e0;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 16px;
    min-height: 100vh;
  }
  h1 {
    font-size: 1.5em;
    margin-bottom: 10px;
    color: #fff;
    letter-spacing: 1px;
  }
  #status {
    background: rgba(255,255,255,0.06);
    backdrop-filter: blur(8px);
    padding: 8px 20px;
    border-radius: 8px;
    margin-bottom: 14px;
    font-family: 'SF Mono', 'Fira Code', monospace;
    font-size: 0.85em;
    border: 1px solid rgba(255,255,255,0.08);
  }
  .s-idle { color: #4ecca3; }
  .s-moving { color: #f7b731; }
  .s-scanning { color: #45aaf2; }
  .s-planning { color: #a55eea; }
  .s-exploring { color: #ff6b81; }
  .s-error { color: #fc5c65; }
  #status .label { color: #888; }
  #status .val { color: #4ecca3; }

  .canvas-wrap {
    position: relative;
    border-radius: 6px;
    overflow: hidden;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  }
  canvas {
    display: block;
    cursor: crosshair;
  }
  /* Axis labels drawn on canvas, but we add a subtle info line below */
  #hint {
    font-size: 0.75em;
    color: #555;
    margin-top: 10px;
    font-style: italic;
  }
  #explore-btn {
    margin-top: 8px;
    padding: 8px 24px;
    border: 1px solid rgba(255,107,129,0.4);
    background: rgba(255,107,129,0.12);
    color: #ff6b81;
    border-radius: 6px;
    font-family: 'SF Mono', monospace;
    font-size: 0.85em;
    cursor: pointer;
    transition: background 0.15s;
  }
  #explore-btn:hover { background: rgba(255,107,129,0.25); }
  #explore-btn.active {
    border-color: rgba(252,92,101,0.6);
    background: rgba(252,92,101,0.2);
    color: #fc5c65;
  }
</style>
</head>
<body>

<h1>ü§ñ RoboTrail</h1>
<div id="status">
  <span class="label">State:</span> <span id="st" class="s-idle">--</span>
  &nbsp;¬∑&nbsp;
  <span class="label">Pose:</span> <span id="pose" class="val">--</span>
  &nbsp;¬∑&nbsp;
  <span id="msg" style="color:#777">--</span>
</div>
<div id="icp-info" style="font-family:'SF Mono',monospace;font-size:0.8em;margin-bottom:4px;color:#666">
  ICP: <span id="icp">--</span>
</div>
<div id="pid-info" style="font-family:'SF Mono',monospace;font-size:0.8em;margin-bottom:10px;color:#666">
  PID: <span id="pid">waiting for movement...</span>
</div>
<div class="canvas-wrap">
  <canvas id="c" width="800" height="800"></canvas>
</div>
<div id="hint">click on map to move robot</div>
<button id="explore-btn" onclick="toggleExplore()">üîç Explore</button>
<div style="margin-top:12px;width:800px">
  <canvas id="pid-chart" height="150" style="background:#12121f;border-radius:4px"></canvas>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

let mapData = null;     // {grid, bounds, rows, cols, version}
let mapVersion = -1;    // track last fetched version
let pose = [0, 0, 0];
let target = null;
let state = 'IDLE';
let path = [];          // [(x,y), ...] visited positions
let planned = [];       // [(x,y), ...] planned waypoints
let icpCorr = [];       // [{from, to}, ...] ICP corrections
let frontiers = [];     // [{centroid, size, cells}, ...]
let exploreGoal = null; // [x, y] current explore target
let exploring = false;  // whether in explore mode

// ‚îÄ‚îÄ Single unified poll ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

setInterval(poll, 1000);

function poll() {
  fetch('/api/state').then(r => r.json()).then(d => {
    state = d.state;
    pose = d.pose;
    target = d.target;
    path = d.path || [];
    planned = d.planned || [];
    icpCorr = d.icp_corrections || [];
    frontiers = d.frontiers || [];
    exploreGoal = d.explore_goal;
    exploring = d.exploring || false;

    // Update explore button state
    const btn = document.getElementById('explore-btn');
    if (exploring) {
      btn.textContent = '‚èπ Stop Exploring';
      btn.classList.add('active');
    } else {
      btn.textContent = 'üîç Explore';
      btn.classList.remove('active');
    }

    // Update status bar
    const stEl = document.getElementById('st');
    stEl.textContent = d.state;
    stEl.className = 's-' + d.state.toLowerCase();
    document.getElementById('pose').textContent =
      `(${d.pose[0].toFixed(1)}, ${d.pose[1].toFixed(1)}, ${d.pose[2].toFixed(0)}¬∞)`;
    document.getElementById('msg').textContent = d.message;

    // ICP display
    const icpEl = document.getElementById('icp');
    if (d.icp) {
      if (d.icp.status === 'converged') {
        icpEl.style.color = '#4ecca3';
        icpEl.textContent = `‚úì dx=${d.icp.dx} dy=${d.icp.dy} dŒ∏=${d.icp.dtheta}¬∞ (${d.icp.map_pts} map pts)`;
      } else if (d.icp.status === 'failed') {
        icpEl.style.color = '#fc5c65';
        icpEl.textContent = `‚úó failed (${d.icp.map_pts} map pts)`;
      } else if (d.icp.status === 'building_map') {
        icpEl.style.color = '#f7b731';
        icpEl.textContent = 'building initial map...';
      } else {
        icpEl.style.color = '#666';
        icpEl.textContent = d.icp.status;
      }
    }

    // PID charts
    const pidEl = document.getElementById('pid');
    if (d.pid && d.pid.t && d.pid.t.length > 1) {
      pidEl.style.color = '#b0b0b0';
      const n = d.pid.t.length;
      const dur = d.pid.t[n-1].toFixed(1);
      pidEl.textContent = `${n} samples over ${dur}s`;
      drawPidCharts(d.pid);
    }

    // Fetch map only when version changes
    if (d.map_version !== mapVersion) {
      mapVersion = d.map_version;
      fetchMap();
    } else {
      draw(); // still redraw for target/pose overlay updates
    }
  }).catch(() => {});
}

function fetchMap() {
  fetch('/api/map').then(r => r.json()).then(d => {
    mapData = d;
    draw();
  }).catch(() => {});
}

// ‚îÄ‚îÄ Click to move ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

canvas.onclick = (e) => {
  if (state !== 'IDLE') return;
  if (!mapData || !mapLayout) return;

  const rect = canvas.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;
  const [xmin, xmax, ymin, ymax] = mapData.bounds;
  const {ox, oy, w, h} = mapLayout;

  // Only respond to clicks inside the map area
  if (px < ox || px > ox + w || py < oy || py > oy + h) return;

  const wx = xmin + ((px - ox) / w) * (xmax - xmin);
  const wy = ymax - ((py - oy) / h) * (ymax - ymin);

  if (confirm(`Move to (${wx.toFixed(0)}, ${wy.toFixed(0)}) cm?`)) {
    fetch('/api/target', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({x: wx, y: wy})
    });
  }
};

// ‚îÄ‚îÄ Colormap ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 3-stop linear: free=dark blue-gray, unknown=very dark, occupied=bright cyan

function probToColor(p) {
  if (p < 0.5) {
    // Free (0) ‚Üí Unknown (0.5)
    // p=0: explored free space, show as visible dark blue-gray
    // p=0.5: unknown/unseen, show as dark background
    const t = p / 0.5;
    return [
      lerp(35, 14, t),
      lerp(50, 16, t),
      lerp(70, 28, t),
    ];
  } else {
    // Unknown (0.5) ‚Üí Occupied (1.0)
    // Linear ramp to bright cyan-green
    const t = (p - 0.5) / 0.5;
    return [
      lerp(14, 0, t),
      lerp(16, 230, t),
      lerp(28, 180, t),
    ];
  }
}

function lerp(a, b, t) { return Math.round(a + (b - a) * t); }

// ‚îÄ‚îÄ Drawing ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const MARGIN = 40;
let mapLayout = null; // {ox, oy, w, h} ‚Äî map drawing rect, set in draw()

function draw() {
  ctx.fillStyle = '#0e0e1a';
  ctx.fillRect(0, 0, W, H);

  if (!mapData) {
    ctx.fillStyle = '#444';
    ctx.font = '16px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('Waiting for map...', W/2, H/2);
    return;
  }

  const {grid, bounds, rows, cols} = mapData;
  const [xmin, xmax, ymin, ymax] = bounds;

  // Available drawing area
  const avail = W - MARGIN * 2;

  // Preserve aspect ratio
  const worldW = xmax - xmin;
  const worldH = ymax - ymin;
  const scale = Math.min(avail / worldW, avail / worldH);
  const drawW = worldW * scale;
  const drawH = worldH * scale;

  // Center in available area
  const ox = MARGIN + (avail - drawW) / 2;
  const oy = MARGIN + (avail - drawH) / 2;

  mapLayout = {ox, oy, w: drawW, h: drawH};

  // Build pixel image from grid
  const imgData = ctx.createImageData(cols, rows);
  const d = imgData.data;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const p = grid[r][c];
      const [cr, cg, cb] = probToColor(p);
      const imgRow = rows - 1 - r; // flip Y
      const idx = (imgRow * cols + c) * 4;
      d[idx] = cr;
      d[idx+1] = cg;
      d[idx+2] = cb;
      d[idx+3] = 255;
    }
  }

  // Render: crisp pixels (no blurring)
  const offscreen = new OffscreenCanvas(cols, rows);
  const offCtx = offscreen.getContext('2d');
  offCtx.putImageData(imgData, 0, 0);

  ctx.imageSmoothingEnabled = false; // crisp pixels
  ctx.drawImage(offscreen, ox, oy, drawW, drawH);

  // ‚îÄ‚îÄ Traversability overlay (blue tint on drivable cells) ‚îÄ‚îÄ‚îÄ‚îÄ
  if (mapData.traversable) {
    const travCanvas = new OffscreenCanvas(cols, rows);
    const travCtx = travCanvas.getContext('2d');
    const travImg = travCtx.createImageData(cols, rows);
    const td = travImg.data;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const imgRow = rows - 1 - r;
        const idx = (imgRow * cols + c) * 4;
        if (mapData.traversable[r][c]) {
          td[idx] = 52; td[idx+1] = 152; td[idx+2] = 219; td[idx+3] = 50;
        }
      }
    }
    travCtx.putImageData(travImg, 0, 0);
    ctx.drawImage(travCanvas, ox, oy, drawW, drawH);
  }

  // ‚îÄ‚îÄ Grid lines + axis labels ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ctx.fillStyle = '#555';
  ctx.font = '11px monospace';
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 0.5;

  // X axis
  ctx.textAlign = 'center';
  const nTicks = 5;
  for (let i = 0; i <= nTicks; i++) {
    const val = xmin + worldW * i / nTicks;
    const px = ox + drawW * i / nTicks;
    ctx.fillText(val.toFixed(0), px, oy + drawH + 16);
    ctx.beginPath(); ctx.moveTo(px, oy); ctx.lineTo(px, oy + drawH); ctx.stroke();
  }

  // Y axis
  ctx.textAlign = 'right';
  for (let i = 0; i <= nTicks; i++) {
    const val = ymin + worldH * i / nTicks;
    const py = oy + drawH - drawH * i / nTicks;
    ctx.fillText(val.toFixed(0), ox - 4, py + 4);
    ctx.beginPath(); ctx.moveTo(ox, py); ctx.lineTo(ox + drawW, py); ctx.stroke();
  }
  // ‚îÄ‚îÄ Path history ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (path.length > 1) {
    ctx.strokeStyle = 'rgba(255, 200, 80, 0.6)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    const [px0, py0] = w2c(path[0][0], path[0][1]);
    ctx.moveTo(px0, py0);
    for (let i = 1; i < path.length; i++) {
      const [px, py] = w2c(path[i][0], path[i][1]);
      ctx.lineTo(px, py);
    }
    ctx.stroke();

    // Dots at each waypoint
    ctx.fillStyle = 'rgba(255, 200, 80, 0.9)';
    for (const pt of path) {
      const [px, py] = w2c(pt[0], pt[1]);
      ctx.beginPath();
      ctx.arc(px, py, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // ‚îÄ‚îÄ Planned path (cyan dashed) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (planned.length > 1) {
    ctx.strokeStyle = 'rgba(165, 94, 234, 0.7)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 4]);
    ctx.beginPath();
    const [pp0, pp1] = w2c(planned[0][0], planned[0][1]);
    ctx.moveTo(pp0, pp1);
    for (let i = 1; i < planned.length; i++) {
      const [px, py] = w2c(planned[i][0], planned[i][1]);
      ctx.lineTo(px, py);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // Dots at planned waypoints
    ctx.fillStyle = 'rgba(165, 94, 234, 0.9)';
    for (const pt of planned) {
      const [px, py] = w2c(pt[0], pt[1]);
      ctx.beginPath();
      ctx.arc(px, py, 3.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // ‚îÄ‚îÄ ICP corrections (arrows from odom ‚Üí corrected) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  for (const c of icpCorr) {
    const [fx, fy] = w2c(c.from[0], c.from[1]);
    const [tx, ty] = w2c(c.to[0], c.to[1]);
    const len = Math.hypot(tx - fx, ty - fy);
    if (len < 2) continue;
    // Arrow line
    ctx.strokeStyle = 'rgba(252, 92, 101, 0.7)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(fx, fy); ctx.lineTo(tx, ty); ctx.stroke();
    // Arrowhead
    const angle = Math.atan2(ty - fy, tx - fx);
    ctx.fillStyle = 'rgba(252, 92, 101, 0.7)';
    ctx.beginPath();
    ctx.moveTo(tx, ty);
    ctx.lineTo(tx - 6 * Math.cos(angle - 0.5), ty - 6 * Math.sin(angle - 0.5));
    ctx.lineTo(tx - 6 * Math.cos(angle + 0.5), ty - 6 * Math.sin(angle + 0.5));
    ctx.closePath();
    ctx.fill();
    // Hollow circle at odom position
    ctx.strokeStyle = 'rgba(252, 92, 101, 0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(fx, fy, 3, 0, Math.PI * 2); ctx.stroke();
  }

  // ‚îÄ‚îÄ Robot ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const [rx, ry] = w2c(pose[0], pose[1]);
  const heading = pose[2] * Math.PI / 180;
  const sz = 12;

  ctx.save();
  ctx.translate(rx, ry);
  ctx.rotate(-heading);
  ctx.beginPath();
  ctx.moveTo(sz, 0);
  ctx.lineTo(-sz * 0.7, -sz * 0.55);
  ctx.lineTo(-sz * 0.3, 0);
  ctx.lineTo(-sz * 0.7, sz * 0.55);
  ctx.closePath();
  ctx.fillStyle = '#e74c3c';
  ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  ctx.restore();

  // ‚îÄ‚îÄ Target ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (target) {
    const [tx, ty] = w2c(target[0], target[1]);
    ctx.strokeStyle = '#4ecca3';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(tx-8, ty); ctx.lineTo(tx+8, ty); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(tx, ty-8); ctx.lineTo(tx, ty+8); ctx.stroke();
    ctx.beginPath(); ctx.arc(tx, ty, 5, 0, Math.PI*2); ctx.stroke();
  }

  // ‚îÄ‚îÄ Frontier clusters (orange dots) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  for (const f of frontiers) {
    // Draw frontier cells as small dots
    ctx.fillStyle = 'rgba(46, 204, 113, 0.5)';
    for (const cell of f.cells) {
      const [fx, fy] = w2c(cell[0], cell[1]);
      ctx.fillRect(fx - 1.5, fy - 1.5, 3, 3);
    }
    // Centroid marker
    const [cx, cy] = w2c(f.centroid[0], f.centroid[1]);
    ctx.fillStyle = '#2ecc71';
    ctx.beginPath();
    ctx.arc(cx, cy, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.stroke();
    // Size label
    ctx.fillStyle = '#2ecc71';
    ctx.font = '9px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(f.size, cx + 7, cy + 3);
  }

  // ‚îÄ‚îÄ Explore goal (orange crosshair) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (exploreGoal) {
    const [ex, ey] = w2c(exploreGoal[0], exploreGoal[1]);
    ctx.strokeStyle = '#ff6b81';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(ex-10, ey); ctx.lineTo(ex+10, ey); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ex, ey-10); ctx.lineTo(ex, ey+10); ctx.stroke();
    ctx.beginPath(); ctx.arc(ex, ey, 7, 0, Math.PI*2); ctx.stroke();
  }
}

function w2c(wx, wy) {
  if (!mapData || !mapLayout) return [0, 0];
  const [xmin, xmax, ymin, ymax] = mapData.bounds;
  const {ox, oy, w, h} = mapLayout;
  return [
    ox + ((wx - xmin) / (xmax - xmin)) * w,
    oy + ((ymax - wy) / (ymax - ymin)) * h,
  ];
}

draw();
poll();

function toggleExplore() {
  if (exploring) {
    fetch('/api/explore/stop', { method: 'POST' });
  } else {
    fetch('/api/explore', { method: 'POST' });
  }
}

// ‚îÄ‚îÄ PID Chart (Chart.js) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

let pidChart = null;

function drawPidCharts(pid) {
  const labels = pid.t.map(v => v.toFixed(2));

  const data = {
    labels,
    datasets: [
      {
        label: 'Left PWM',
        data: pid.left_pwm,
        borderColor: '#45aaf2',
        borderWidth: 1.5,
        pointRadius: 0,
        yAxisID: 'yPWM',
      },
      {
        label: 'Right PWM',
        data: pid.right_pwm,
        borderColor: '#f7b731',
        borderWidth: 1.5,
        pointRadius: 0,
        yAxisID: 'yPWM',
      },
      {
        label: 'Heading Error',
        data: pid.heading_error,
        borderColor: '#4ecca3',
        borderWidth: 1.5,
        pointRadius: 0,
        borderDash: [4, 2],
        yAxisID: 'yErr',
      },
    ],
  };

  const opts = {
    responsive: true,
    animation: false,
    interaction: { mode: 'index', intersect: false },
    plugins: {
      legend: {
        labels: { color: '#888', font: { size: 10, family: 'monospace' }, boxWidth: 12 },
      },
    },
    scales: {
      x: {
        title: { display: true, text: 'Time (s)', color: '#555', font: { size: 10 } },
        ticks: { color: '#555', font: { size: 9 }, maxTicksLimit: 8 },
        grid: { color: 'rgba(255,255,255,0.05)' },
      },
      yPWM: {
        type: 'linear',
        position: 'left',
        title: { display: true, text: 'PWM %', color: '#45aaf2', font: { size: 10 } },
        ticks: { color: '#45aaf2', font: { size: 9 } },
        grid: { color: 'rgba(255,255,255,0.05)' },
        min: 0,
      },
      yErr: {
        type: 'linear',
        position: 'right',
        title: { display: true, text: 'Heading Err ¬∞', color: '#4ecca3', font: { size: 10 } },
        ticks: { color: '#4ecca3', font: { size: 9 } },
        grid: { drawOnChartArea: false },
      },
    },
  };

  if (pidChart) {
    pidChart.data = data;
    pidChart.update();
  } else {
    pidChart = new Chart(document.getElementById('pid-chart'), {
      type: 'line',
      data,
      options: opts,
    });
  }
}
</script>
</body>
</html>
