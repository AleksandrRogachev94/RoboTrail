<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RoboTrail</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: system-ui, sans-serif;
    background: #0f0f1a;
    color: #e0e0e0;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 16px;
    min-height: 100vh;
  }
  h1 {
    font-size: 1.5em;
    margin-bottom: 10px;
    color: #fff;
    letter-spacing: 1px;
  }
  #status {
    background: rgba(255,255,255,0.06);
    backdrop-filter: blur(8px);
    padding: 8px 20px;
    border-radius: 8px;
    margin-bottom: 14px;
    font-family: 'SF Mono', 'Fira Code', monospace;
    font-size: 0.85em;
    border: 1px solid rgba(255,255,255,0.08);
  }
  .s-idle { color: #4ecca3; }
  .s-moving { color: #f7b731; }
  .s-scanning { color: #45aaf2; }
  .s-error { color: #fc5c65; }
  #status .label { color: #888; }
  #status .val { color: #4ecca3; }

  .canvas-wrap {
    position: relative;
    border-radius: 6px;
    overflow: hidden;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  }
  canvas {
    display: block;
    cursor: crosshair;
  }
  /* Axis labels drawn on canvas, but we add a subtle info line below */
  #hint {
    font-size: 0.75em;
    color: #555;
    margin-top: 10px;
    font-style: italic;
  }
</style>
</head>
<body>

<h1>ðŸ¤– RoboTrail</h1>
<div id="status">
  <span class="label">State:</span> <span id="st" class="s-idle">--</span>
  &nbsp;Â·&nbsp;
  <span class="label">Pose:</span> <span id="pose" class="val">--</span>
  &nbsp;Â·&nbsp;
  <span id="msg" style="color:#777">--</span>
</div>
<div class="canvas-wrap">
  <canvas id="c" width="720" height="720"></canvas>
</div>
<div id="hint">click on map to move robot</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

let mapData = null;     // {grid, bounds, rows, cols, version}
let mapVersion = -1;    // track last fetched version
let pose = [0, 0, 0];
let target = null;
let state = 'IDLE';

// â”€â”€ Single unified poll â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

setInterval(poll, 1000);

function poll() {
  fetch('/api/state').then(r => r.json()).then(d => {
    state = d.state;
    pose = d.pose;
    target = d.target;

    // Update status bar
    const stEl = document.getElementById('st');
    stEl.textContent = d.state;
    stEl.className = 's-' + d.state.toLowerCase();
    document.getElementById('pose').textContent =
      `(${d.pose[0].toFixed(1)}, ${d.pose[1].toFixed(1)}, ${d.pose[2].toFixed(0)}Â°)`;
    document.getElementById('msg').textContent = d.message;

    // Fetch map only when version changes
    if (d.map_version !== mapVersion) {
      mapVersion = d.map_version;
      fetchMap();
    } else {
      draw(); // still redraw for target/pose overlay updates
    }
  }).catch(() => {});
}

function fetchMap() {
  fetch('/api/map').then(r => r.json()).then(d => {
    mapData = d;
    draw();
  }).catch(() => {});
}

// â”€â”€ Click to move â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

canvas.onclick = (e) => {
  if (state !== 'IDLE') return;
  if (!mapData || !mapLayout) return;

  const rect = canvas.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;
  const [xmin, xmax, ymin, ymax] = mapData.bounds;
  const {ox, oy, w, h} = mapLayout;

  // Only respond to clicks inside the map area
  if (px < ox || px > ox + w || py < oy || py > oy + h) return;

  const wx = xmin + ((px - ox) / w) * (xmax - xmin);
  const wy = ymax - ((py - oy) / h) * (ymax - ymin);

  if (confirm(`Move to (${wx.toFixed(0)}, ${wy.toFixed(0)}) cm?`)) {
    fetch('/api/target', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({x: wx, y: wy})
    });
  }
};

// â”€â”€ Colormap â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function probToColor(p) {
  // Dark everywhere. Only walls pop.
  const bg = [14, 16, 28]; // base dark

  if (p < 0.4) {
    // Free space: very slightly lighter than background
    return [18, 22, 38];
  } else if (p < 0.6) {
    // Unknown: dark base
    return bg;
  } else {
    // Occupied (0.6â†’1.0): ramp to bright cyan-green
    const t = (p - 0.6) / 0.4; // 0â†’1
    const t3 = t * t * t; // cubic ease-in: only very high p glows
    return [
      lerp(14, 80, t3),    // R: stays dark
      lerp(16, 255, t3),   // G: bright green
      lerp(28, 220, t3),   // B: cyan tint
    ];
  }
}

function lerp(a, b, t) { return Math.round(a + (b - a) * t); }

// â”€â”€ Drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const MARGIN = 40;
let mapLayout = null; // {ox, oy, w, h} â€” map drawing rect, set in draw()

function draw() {
  ctx.fillStyle = '#0e0e1a';
  ctx.fillRect(0, 0, W, H);

  if (!mapData) {
    ctx.fillStyle = '#444';
    ctx.font = '16px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('Waiting for map...', W/2, H/2);
    return;
  }

  const {grid, bounds, rows, cols} = mapData;
  const [xmin, xmax, ymin, ymax] = bounds;

  // Available drawing area
  const avail = W - MARGIN * 2;

  // Preserve aspect ratio
  const worldW = xmax - xmin;
  const worldH = ymax - ymin;
  const scale = Math.min(avail / worldW, avail / worldH);
  const drawW = worldW * scale;
  const drawH = worldH * scale;

  // Center in available area
  const ox = MARGIN + (avail - drawW) / 2;
  const oy = MARGIN + (avail - drawH) / 2;

  mapLayout = {ox, oy, w: drawW, h: drawH};

  // Build pixel image from grid
  const imgData = ctx.createImageData(cols, rows);
  const d = imgData.data;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const p = grid[r][c];
      const [cr, cg, cb] = probToColor(p);
      const imgRow = rows - 1 - r; // flip Y
      const idx = (imgRow * cols + c) * 4;
      d[idx] = cr;
      d[idx+1] = cg;
      d[idx+2] = cb;
      d[idx+3] = 255;
    }
  }

  // Render: crisp pixels (no blurring)
  const offscreen = new OffscreenCanvas(cols, rows);
  const offCtx = offscreen.getContext('2d');
  offCtx.putImageData(imgData, 0, 0);

  ctx.imageSmoothingEnabled = false; // crisp pixels
  ctx.drawImage(offscreen, ox, oy, drawW, drawH);

  // â”€â”€ Grid lines + axis labels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ctx.fillStyle = '#555';
  ctx.font = '11px monospace';
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 0.5;

  // X axis
  ctx.textAlign = 'center';
  const nTicks = 5;
  for (let i = 0; i <= nTicks; i++) {
    const val = xmin + worldW * i / nTicks;
    const px = ox + drawW * i / nTicks;
    ctx.fillText(val.toFixed(0), px, oy + drawH + 16);
    ctx.beginPath(); ctx.moveTo(px, oy); ctx.lineTo(px, oy + drawH); ctx.stroke();
  }

  // Y axis
  ctx.textAlign = 'right';
  for (let i = 0; i <= nTicks; i++) {
    const val = ymin + worldH * i / nTicks;
    const py = oy + drawH - drawH * i / nTicks;
    ctx.fillText(val.toFixed(0), ox - 4, py + 4);
    ctx.beginPath(); ctx.moveTo(ox, py); ctx.lineTo(ox + drawW, py); ctx.stroke();
  }

  // â”€â”€ Robot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [rx, ry] = w2c(pose[0], pose[1]);
  const heading = pose[2] * Math.PI / 180;
  const sz = 12;

  ctx.save();
  ctx.translate(rx, ry);
  ctx.rotate(-heading);
  ctx.beginPath();
  ctx.moveTo(sz, 0);
  ctx.lineTo(-sz * 0.7, -sz * 0.55);
  ctx.lineTo(-sz * 0.3, 0);
  ctx.lineTo(-sz * 0.7, sz * 0.55);
  ctx.closePath();
  ctx.fillStyle = '#e74c3c';
  ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  ctx.restore();

  // â”€â”€ Target â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (target) {
    const [tx, ty] = w2c(target[0], target[1]);
    ctx.strokeStyle = '#4ecca3';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(tx-8, ty); ctx.lineTo(tx+8, ty); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(tx, ty-8); ctx.lineTo(tx, ty+8); ctx.stroke();
    ctx.beginPath(); ctx.arc(tx, ty, 5, 0, Math.PI*2); ctx.stroke();
  }
}

function w2c(wx, wy) {
  if (!mapData || !mapLayout) return [0, 0];
  const [xmin, xmax, ymin, ymax] = mapData.bounds;
  const {ox, oy, w, h} = mapLayout;
  return [
    ox + ((wx - xmin) / (xmax - xmin)) * w,
    oy + ((ymax - wy) / (ymax - ymin)) * h,
  ];
}

// Initial
draw();
poll();
</script>
</body>
</html>
