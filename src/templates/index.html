<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RoboTrail</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: system-ui, sans-serif;
    background: #0f0f1a;
    color: #e0e0e0;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 16px;
    min-height: 100vh;
  }
  h1 {
    font-size: 1.5em;
    margin-bottom: 10px;
    color: #fff;
    letter-spacing: 1px;
  }
  #status {
    background: rgba(255,255,255,0.06);
    backdrop-filter: blur(8px);
    padding: 8px 20px;
    border-radius: 8px;
    margin-bottom: 14px;
    font-family: 'SF Mono', 'Fira Code', monospace;
    font-size: 0.85em;
    border: 1px solid rgba(255,255,255,0.08);
  }
  .s-idle { color: #4ecca3; }
  .s-moving { color: #f7b731; }
  .s-scanning { color: #45aaf2; }
  .s-error { color: #fc5c65; }
  #status .label { color: #888; }
  #status .val { color: #4ecca3; }

  .canvas-wrap {
    position: relative;
    border-radius: 6px;
    overflow: hidden;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  }
  canvas {
    display: block;
    cursor: crosshair;
  }
  /* Axis labels drawn on canvas, but we add a subtle info line below */
  #hint {
    font-size: 0.75em;
    color: #555;
    margin-top: 10px;
    font-style: italic;
  }
</style>
</head>
<body>

<h1>ðŸ¤– RoboTrail</h1>
<div id="status">
  <span class="label">State:</span> <span id="st" class="s-idle">--</span>
  &nbsp;Â·&nbsp;
  <span class="label">Pose:</span> <span id="pose" class="val">--</span>
  &nbsp;Â·&nbsp;
  <span id="msg" style="color:#777">--</span>
</div>
<div id="icp-info" style="font-family:'SF Mono',monospace;font-size:0.8em;margin-bottom:4px;color:#666">
  ICP: <span id="icp">--</span>
</div>
<div id="pid-info" style="font-family:'SF Mono',monospace;font-size:0.8em;margin-bottom:10px;color:#666">
  PID: <span id="pid">waiting for movement...</span>
</div>
<div class="canvas-wrap">
  <canvas id="c" width="720" height="720"></canvas>
</div>
<div id="hint">click on map to move robot</div>
<div style="margin-top:12px;width:720px">
  <canvas id="pid-chart" height="150" style="background:#12121f;border-radius:4px"></canvas>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

let mapData = null;     // {grid, bounds, rows, cols, version}
let mapVersion = -1;    // track last fetched version
let pose = [0, 0, 0];
let target = null;
let state = 'IDLE';
let path = [];          // [(x,y), ...] visited positions

// â”€â”€ Single unified poll â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

setInterval(poll, 1000);

function poll() {
  fetch('/api/state').then(r => r.json()).then(d => {
    state = d.state;
    pose = d.pose;
    target = d.target;
    path = d.path || [];

    // Update status bar
    const stEl = document.getElementById('st');
    stEl.textContent = d.state;
    stEl.className = 's-' + d.state.toLowerCase();
    document.getElementById('pose').textContent =
      `(${d.pose[0].toFixed(1)}, ${d.pose[1].toFixed(1)}, ${d.pose[2].toFixed(0)}Â°)`;
    document.getElementById('msg').textContent = d.message;

    // ICP display
    const icpEl = document.getElementById('icp');
    if (d.icp) {
      if (d.icp.status === 'converged') {
        icpEl.style.color = '#4ecca3';
        icpEl.textContent = `âœ“ dx=${d.icp.dx} dy=${d.icp.dy} dÎ¸=${d.icp.dtheta}Â° (${d.icp.map_pts} map pts)`;
      } else if (d.icp.status === 'failed') {
        icpEl.style.color = '#fc5c65';
        icpEl.textContent = `âœ— failed (${d.icp.map_pts} map pts)`;
      } else if (d.icp.status === 'building_map') {
        icpEl.style.color = '#f7b731';
        icpEl.textContent = 'building initial map...';
      } else {
        icpEl.style.color = '#666';
        icpEl.textContent = d.icp.status;
      }
    }

    // PID charts
    const pidEl = document.getElementById('pid');
    if (d.pid && d.pid.t && d.pid.t.length > 1) {
      pidEl.style.color = '#b0b0b0';
      const n = d.pid.t.length;
      const dur = d.pid.t[n-1].toFixed(1);
      pidEl.textContent = `${n} samples over ${dur}s`;
      drawPidCharts(d.pid);
    }

    // Fetch map only when version changes
    if (d.map_version !== mapVersion) {
      mapVersion = d.map_version;
      fetchMap();
    } else {
      draw(); // still redraw for target/pose overlay updates
    }
  }).catch(() => {});
}

function fetchMap() {
  fetch('/api/map').then(r => r.json()).then(d => {
    mapData = d;
    draw();
  }).catch(() => {});
}

// â”€â”€ Click to move â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

canvas.onclick = (e) => {
  if (state !== 'IDLE') return;
  if (!mapData || !mapLayout) return;

  const rect = canvas.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;
  const [xmin, xmax, ymin, ymax] = mapData.bounds;
  const {ox, oy, w, h} = mapLayout;

  // Only respond to clicks inside the map area
  if (px < ox || px > ox + w || py < oy || py > oy + h) return;

  const wx = xmin + ((px - ox) / w) * (xmax - xmin);
  const wy = ymax - ((py - oy) / h) * (ymax - ymin);

  if (confirm(`Move to (${wx.toFixed(0)}, ${wy.toFixed(0)}) cm?`)) {
    fetch('/api/target', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({x: wx, y: wy})
    });
  }
};

// â”€â”€ Colormap â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 3-stop linear: free=dark blue-gray, unknown=very dark, occupied=bright cyan

function probToColor(p) {
  if (p < 0.5) {
    // Free (0) â†’ Unknown (0.5)
    // p=0: explored free space, show as visible dark blue-gray
    // p=0.5: unknown/unseen, show as dark background
    const t = p / 0.5;
    return [
      lerp(35, 14, t),
      lerp(50, 16, t),
      lerp(70, 28, t),
    ];
  } else {
    // Unknown (0.5) â†’ Occupied (1.0)
    // Linear ramp to bright cyan-green
    const t = (p - 0.5) / 0.5;
    return [
      lerp(14, 0, t),
      lerp(16, 230, t),
      lerp(28, 180, t),
    ];
  }
}

function lerp(a, b, t) { return Math.round(a + (b - a) * t); }

// â”€â”€ Drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const MARGIN = 40;
let mapLayout = null; // {ox, oy, w, h} â€” map drawing rect, set in draw()

function draw() {
  ctx.fillStyle = '#0e0e1a';
  ctx.fillRect(0, 0, W, H);

  if (!mapData) {
    ctx.fillStyle = '#444';
    ctx.font = '16px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('Waiting for map...', W/2, H/2);
    return;
  }

  const {grid, bounds, rows, cols} = mapData;
  const [xmin, xmax, ymin, ymax] = bounds;

  // Available drawing area
  const avail = W - MARGIN * 2;

  // Preserve aspect ratio
  const worldW = xmax - xmin;
  const worldH = ymax - ymin;
  const scale = Math.min(avail / worldW, avail / worldH);
  const drawW = worldW * scale;
  const drawH = worldH * scale;

  // Center in available area
  const ox = MARGIN + (avail - drawW) / 2;
  const oy = MARGIN + (avail - drawH) / 2;

  mapLayout = {ox, oy, w: drawW, h: drawH};

  // Build pixel image from grid
  const imgData = ctx.createImageData(cols, rows);
  const d = imgData.data;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const p = grid[r][c];
      const [cr, cg, cb] = probToColor(p);
      const imgRow = rows - 1 - r; // flip Y
      const idx = (imgRow * cols + c) * 4;
      d[idx] = cr;
      d[idx+1] = cg;
      d[idx+2] = cb;
      d[idx+3] = 255;
    }
  }

  // Render: crisp pixels (no blurring)
  const offscreen = new OffscreenCanvas(cols, rows);
  const offCtx = offscreen.getContext('2d');
  offCtx.putImageData(imgData, 0, 0);

  ctx.imageSmoothingEnabled = false; // crisp pixels
  ctx.drawImage(offscreen, ox, oy, drawW, drawH);

  // â”€â”€ Grid lines + axis labels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ctx.fillStyle = '#555';
  ctx.font = '11px monospace';
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 0.5;

  // X axis
  ctx.textAlign = 'center';
  const nTicks = 5;
  for (let i = 0; i <= nTicks; i++) {
    const val = xmin + worldW * i / nTicks;
    const px = ox + drawW * i / nTicks;
    ctx.fillText(val.toFixed(0), px, oy + drawH + 16);
    ctx.beginPath(); ctx.moveTo(px, oy); ctx.lineTo(px, oy + drawH); ctx.stroke();
  }

  // Y axis
  ctx.textAlign = 'right';
  for (let i = 0; i <= nTicks; i++) {
    const val = ymin + worldH * i / nTicks;
    const py = oy + drawH - drawH * i / nTicks;
    ctx.fillText(val.toFixed(0), ox - 4, py + 4);
    ctx.beginPath(); ctx.moveTo(ox, py); ctx.lineTo(ox + drawW, py); ctx.stroke();
  }
  // â”€â”€ Path history â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (path.length > 1) {
    ctx.strokeStyle = 'rgba(78, 204, 163, 0.5)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    const [px0, py0] = w2c(path[0][0], path[0][1]);
    ctx.moveTo(px0, py0);
    for (let i = 1; i < path.length; i++) {
      const [px, py] = w2c(path[i][0], path[i][1]);
      ctx.lineTo(px, py);
    }
    ctx.stroke();

    // Dots at each waypoint
    ctx.fillStyle = 'rgba(78, 204, 163, 0.8)';
    for (const pt of path) {
      const [px, py] = w2c(pt[0], pt[1]);
      ctx.beginPath();
      ctx.arc(px, py, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // â”€â”€ Robot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [rx, ry] = w2c(pose[0], pose[1]);
  const heading = pose[2] * Math.PI / 180;
  const sz = 12;

  ctx.save();
  ctx.translate(rx, ry);
  ctx.rotate(-heading);
  ctx.beginPath();
  ctx.moveTo(sz, 0);
  ctx.lineTo(-sz * 0.7, -sz * 0.55);
  ctx.lineTo(-sz * 0.3, 0);
  ctx.lineTo(-sz * 0.7, sz * 0.55);
  ctx.closePath();
  ctx.fillStyle = '#e74c3c';
  ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  ctx.restore();

  // â”€â”€ Target â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (target) {
    const [tx, ty] = w2c(target[0], target[1]);
    ctx.strokeStyle = '#4ecca3';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(tx-8, ty); ctx.lineTo(tx+8, ty); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(tx, ty-8); ctx.lineTo(tx, ty+8); ctx.stroke();
    ctx.beginPath(); ctx.arc(tx, ty, 5, 0, Math.PI*2); ctx.stroke();
  }
}

function w2c(wx, wy) {
  if (!mapData || !mapLayout) return [0, 0];
  const [xmin, xmax, ymin, ymax] = mapData.bounds;
  const {ox, oy, w, h} = mapLayout;
  return [
    ox + ((wx - xmin) / (xmax - xmin)) * w,
    oy + ((ymax - wy) / (ymax - ymin)) * h,
  ];
}

// Initial
draw();
poll();

// â”€â”€ PID Chart (Chart.js) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let pidChart = null;

function drawPidCharts(pid) {
  const labels = pid.t.map(v => v.toFixed(2));

  const data = {
    labels,
    datasets: [
      {
        label: 'Left PWM',
        data: pid.left_pwm,
        borderColor: '#45aaf2',
        borderWidth: 1.5,
        pointRadius: 0,
        yAxisID: 'yPWM',
      },
      {
        label: 'Right PWM',
        data: pid.right_pwm,
        borderColor: '#f7b731',
        borderWidth: 1.5,
        pointRadius: 0,
        yAxisID: 'yPWM',
      },
      {
        label: 'Heading Error',
        data: pid.heading_error,
        borderColor: '#4ecca3',
        borderWidth: 1.5,
        pointRadius: 0,
        borderDash: [4, 2],
        yAxisID: 'yErr',
      },
    ],
  };

  const opts = {
    responsive: true,
    animation: false,
    interaction: { mode: 'index', intersect: false },
    plugins: {
      legend: {
        labels: { color: '#888', font: { size: 10, family: 'monospace' }, boxWidth: 12 },
      },
    },
    scales: {
      x: {
        title: { display: true, text: 'Time (s)', color: '#555', font: { size: 10 } },
        ticks: { color: '#555', font: { size: 9 }, maxTicksLimit: 8 },
        grid: { color: 'rgba(255,255,255,0.05)' },
      },
      yPWM: {
        type: 'linear',
        position: 'left',
        title: { display: true, text: 'PWM %', color: '#45aaf2', font: { size: 10 } },
        ticks: { color: '#45aaf2', font: { size: 9 } },
        grid: { color: 'rgba(255,255,255,0.05)' },
        min: 0,
      },
      yErr: {
        type: 'linear',
        position: 'right',
        title: { display: true, text: 'Heading Err Â°', color: '#4ecca3', font: { size: 10 } },
        ticks: { color: '#4ecca3', font: { size: 9 } },
        grid: { drawOnChartArea: false },
      },
    },
  };

  if (pidChart) {
    pidChart.data = data;
    pidChart.update();
  } else {
    pidChart = new Chart(document.getElementById('pid-chart'), {
      type: 'line',
      data,
      options: opts,
    });
  }
}
</script>
</body>
</html>
