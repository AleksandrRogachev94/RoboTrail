<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RoboTrail Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: system-ui, -apple-system, sans-serif;
    background: #0b0c10;
    color: #c5c6c7;
    height: 100vh;
    overflow: hidden; /* Prevent scrolling */
    display: flex;
    flex-direction: column;
  }

  /* Header */
  header {
    background: #1f2833;
    padding: 12px 24px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #2d3642;
    box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    z-index: 10;
  }
  h1 { font-size: 1.4em; color: #66fcf1; }

  /* Main Layout */
  .container {
    display: flex;
    flex: 1;
    overflow: hidden;
    padding: 20px;
    gap: 20px;
  }

  /* Left Panel (Map) */
  .map-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: #171d24;
    border-radius: 8px;
    border: 1px solid #2d3642;
    position: relative;
    box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
  }
  .canvas-wrap {
    position: relative;
    border-radius: 4px;
    overflow: hidden;
    /* Fit nicely without forced scrolling */
    max-height: 100%;
    max-width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  canvas#c {
    display: block;
    cursor: crosshair;
    background: #0e0e1a;
    /* Use max constraints so it scales down if screen is small */
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
  }
  #hint {
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 0.8em;
    color: #66fcf1;
    opacity: 0.7;
    font-style: italic;
    background: rgba(0,0,0,0.4);
    padding: 4px 8px;
    border-radius: 4px;
    pointer-events: none;
  }
  #legend {
    position: absolute;
    bottom: 15px;
    left: 15px;
    background: rgba(11, 12, 16, 0.85);
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 0.75em;
    pointer-events: none;
    color: #c5c6c7;
    border: 1px solid #2d3642;
  }
  .leg-item { display: flex; align-items: center; margin-top: 4px; }
  .leg-box { width: 12px; height: 12px; margin-right: 8px; border-radius: 2px; }

  /* Right Panel (Stats & Controls) */
  .side-panel {
    width: 380px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    overflow-y: auto; /* Allow scrolling here if needed, but rarely needed */
  }

  /* Cards */
  .card {
    background: #1f2833;
    border-radius: 8px;
    padding: 16px;
    border: 1px solid #2d3642;
  }
  .card h3 {
    font-size: 0.9em;
    text-transform: uppercase;
    color: #45a29e;
    margin-bottom: 12px;
    letter-spacing: 1px;
    border-bottom: 1px solid #2d3642;
    padding-bottom: 6px;
  }

  /* State / HUD */
  .hud-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }
  .hud-item {
    background: rgba(11,12,16,0.5);
    padding: 8px;
    border-radius: 4px;
    display: flex;
    flex-direction: column;
  }
  .hud-lbl { font-size: 0.7em; color: #888; text-transform: uppercase; margin-bottom: 4px; }
  .hud-val { font-family: 'SF Mono', monospace; font-size: 0.9em; color: #fff; }

  .s-idle { color: #4ecca3 !important; }
  .s-moving { color: #f7b731 !important; }
  .s-scanning { color: #45aaf2 !important; }
  .s-planning { color: #a55eea !important; }
  .s-exploring { color: #ff6b81 !important; }
  .s-error { color: #fc5c65 !important; }

  #msg {
    margin-top: 10px;
    font-size: 0.85em;
    color: #aaa;
    background: rgba(0,0,0,0.2);
    padding: 8px;
    border-radius: 4px;
    white-space: pre-wrap;
    min-height: 2em;
  }

  /* Explore Button */
  #explore-btn {
    width: 100%;
    padding: 12px;
    border: 1px solid rgba(102, 252, 241, 0.4);
    background: rgba(102, 252, 241, 0.1);
    color: #66fcf1;
    border-radius: 6px;
    font-family: inherit;
    font-size: 1.1em;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  #explore-btn:hover { background: rgba(102, 252, 241, 0.25); }
  #explore-btn.active {
    border-color: rgba(252,92,101,0.6);
    background: rgba(252,92,101,0.2);
    color: #fc5c65;
  }

  /* Chart */
  .chart-container {
    height: 180px;
    width: 100%;
    margin-top: 8px;
  }
</style>
</head>
<body>

<header>
  <h1>ü§ñ RoboTrail Dashboard</h1>
  <div style="font-family:'SF Mono',monospace;font-size:0.85em;">
    <span style="color:#888">ICP: </span><span id="icp">--</span>
  </div>
</header>

<div class="container">

  <!-- LEFT: Map -->
  <div class="map-panel">
    <div class="canvas-wrap">
      <canvas id="c" width="800" height="800"></canvas>
    </div>
    <div id="hint">Click map to navigate</div>
    <div id="legend">
      <div class="leg-item"><div class="leg-box" style="background:#e74c3c"></div>Robot</div>
      <div class="leg-item"><div class="leg-box" style="background:rgba(255, 200, 80, 0.9)"></div>Path</div>
      <div class="leg-item"><div class="leg-box" style="background:#fd79a8"></div>Frontier</div>
      <div class="leg-item"><div class="leg-box" style="background:#a55eea"></div>Planned</div>
      <div class="leg-item"><div class="leg-box" style="background:rgba(52, 152, 219, 0.4)"></div>Traversable</div>
    </div>
  </div>

  <!-- RIGHT: Stats & Controls -->
  <div class="side-panel">

    <!-- HUD Card -->
    <div class="card">
      <h3>System HUD</h3>
      <div class="hud-grid">
        <div class="hud-item">
          <span class="hud-lbl">State</span>
          <span id="st" class="hud-val s-idle">--</span>
        </div>
        <div class="hud-item">
          <span class="hud-lbl">Pose (x, y, Œ∏)</span>
          <span id="pose" class="hud-val">--</span>
        </div>
        <div class="hud-item">
          <span class="hud-lbl">Map Version</span>
          <span id="map-ver" class="hud-val">0 scans</span>
        </div>
        <div class="hud-item">
          <span class="hud-lbl">Frontiers Left</span>
          <span id="frontier-count" class="hud-val">0</span>
        </div>
        <div class="hud-item" style="grid-column: span 2;">
          <span class="hud-lbl">Target / Explore Goal</span>
          <span id="target-info" class="hud-val">None</span>
        </div>
      </div>
      <div id="msg">--</div>
    </div>

    <!-- Controls Card -->
    <div class="card">
      <h3>Exploration</h3>
      <button id="explore-btn" onclick="toggleExplore()">üîç Start Exploring</button>
    </div>

    <!-- Diagnostics Card -->
    <div class="card">
      <h3>Motion Diagnostics</h3>
      <div id="pid" style="font-family:'SF Mono',monospace;font-size:0.75em;color:#888;margin-bottom:4px;">
        waiting for movement...
      </div>
      <div class="chart-container">
        <canvas id="pid-chart"></canvas>
      </div>
    </div>

  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

let mapData = null;     // {grid, bounds, rows, cols, version}
let mapVersion = -1;    // track last fetched version
let pose = [0, 0, 0];
let target = null;
let state = 'IDLE';
let path = [];          // [(x,y), ...] visited positions
let planned = [];       // [(x,y), ...] planned waypoints
let icpCorr = [];       // [{from, to}, ...] ICP corrections
let frontiers = [];     // [{centroid, size, cells}, ...]
let exploreGoal = null; // [x, y] current explore target
let exploring = false;  // whether in explore mode

// ‚îÄ‚îÄ Single unified poll ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

setInterval(poll, 1000);

function poll() {
  fetch('/api/state').then(r => r.json()).then(d => {
    state = d.state;
    pose = d.pose;
    target = d.target;
    path = d.path || [];
    planned = d.planned || [];
    icpCorr = d.icp_corrections || [];
    frontiers = d.frontiers || [];
    exploreGoal = d.explore_goal;
    exploring = d.exploring || false;

    // Update explore button state
    const btn = document.getElementById('explore-btn');
    if (exploring) {
      btn.textContent = '‚èπ Stop Exploring';
      btn.classList.add('active');
    } else {
      btn.textContent = 'üîç Start Exploring';
      btn.classList.remove('active');
    }

    // Update system HUD
    const stEl = document.getElementById('st');
    stEl.textContent = d.state;
    stEl.className = 'hud-val s-' + d.state.toLowerCase();

    document.getElementById('pose').textContent =
      `${d.pose[0].toFixed(1)}, ${d.pose[1].toFixed(1)}, ${d.pose[2].toFixed(0)}¬∞`;

    document.getElementById('map-ver').textContent = `${d.map_version} scans`;
    document.getElementById('frontier-count').textContent = frontiers.length;

    // Target computation
    let tgtDisplay = "None";
    if (target) {
        const dist = Math.hypot(target[0] - pose[0], target[1] - pose[1]);
        tgtDisplay = `User Map Click (${dist.toFixed(0)}cm away)`;
    } else if (exploreGoal) {
        const dist = Math.hypot(exploreGoal[0] - pose[0], exploreGoal[1] - pose[1]);
        tgtDisplay = `Frontier (${dist.toFixed(0)}cm away)`;
    }
    document.getElementById('target-info').textContent = tgtDisplay;

    document.getElementById('msg').textContent = d.message || "Idle";

    // Header ICP Status
    const icpEl = document.getElementById('icp');
    if (d.icp) {
      if (d.icp.status === 'converged') {
        icpEl.style.color = '#4ecca3';
        icpEl.textContent = `‚úì dx=${d.icp.dx} dy=${d.icp.dy} dŒ∏=${d.icp.dtheta}¬∞ (${d.icp.map_pts} map pts)`;
      } else if (d.icp.status === 'failed') {
        icpEl.style.color = '#fc5c65';
        icpEl.textContent = `‚úó failed (${d.icp.map_pts} map pts)`;
      } else if (d.icp.status === 'building_map') {
        icpEl.style.color = '#f7b731';
        icpEl.textContent = 'building initial map...';
      } else {
        icpEl.style.color = '#888';
        icpEl.textContent = d.icp.status;
      }
    }

    // PID diagnostics
    const pidEl = document.getElementById('pid');
    if (d.pid && d.pid.t && d.pid.t.length > 1) {
      const n = d.pid.t.length;
      const dur = d.pid.t[n-1].toFixed(1);
      pidEl.textContent = `Last Move: ${n} points over ${dur}s`;
      drawPidCharts(d.pid);
    }

    // Map refresh logic
    if (d.map_version !== mapVersion) {
      mapVersion = d.map_version;
      fetchMap();
    } else {
      draw(); // still redraw for overlays
    }
  }).catch(() => {});
}

function fetchMap() {
  fetch('/api/map').then(r => r.json()).then(d => {
    mapData = d;
    draw();
  }).catch(() => {});
}

// ‚îÄ‚îÄ Click to move ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

canvas.onclick = (e) => {
  if (state !== 'IDLE') return;
  if (!mapData || !mapLayout) return;

  const rect = canvas.getBoundingClientRect();
  // Adjust for CSS scaling vs Canvas real resolution
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;

  const px = (e.clientX - rect.left) * scaleX;
  const py = (e.clientY - rect.top) * scaleY;

  const [xmin, xmax, ymin, ymax] = mapData.bounds;
  const {ox, oy, w, h} = mapLayout;

  if (px < ox || px > ox + w || py < oy || py > oy + h) return;

  const wx = xmin + ((px - ox) / w) * (xmax - xmin);
  const wy = ymax - ((py - oy) / h) * (ymax - ymin);

  if (confirm(`Move to (${wx.toFixed(0)}, ${wy.toFixed(0)}) cm?`)) {
    fetch('/api/target', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({x: wx, y: wy})
    });
  }
};

// ‚îÄ‚îÄ Colormap ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function probToColor(p) {
  if (p < 0.5) {
    const t = p / 0.5;
    return [lerp(35, 14, t), lerp(50, 16, t), lerp(70, 28, t)];
  } else {
    const t = (p - 0.5) / 0.5;
    return [lerp(14, 0, t), lerp(16, 230, t), lerp(28, 180, t)];
  }
}
function lerp(a, b, t) { return Math.round(a + (b - a) * t); }

// ‚îÄ‚îÄ Drawing ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const MARGIN = 40;
let mapLayout = null;

function draw() {
  ctx.fillStyle = '#0e0e1a';
  ctx.fillRect(0, 0, W, H);

  if (!mapData) {
    ctx.fillStyle = '#444';
    ctx.font = '16px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('Waiting for map...', W/2, H/2);
    return;
  }

  const {grid, bounds, rows, cols} = mapData;
  const [xmin, xmax, ymin, ymax] = bounds;

  const availW = W - MARGIN * 2;
  const availH = H - MARGIN * 2;
  const worldW = xmax - xmin;
  const worldH = ymax - ymin;

  const scale = Math.min(availW / worldW, availH / worldH);
  const drawW = worldW * scale;
  const drawH = worldH * scale;

  const ox = MARGIN + (availW - drawW) / 2;
  const oy = MARGIN + (availH - drawH) / 2;
  mapLayout = {ox, oy, w: drawW, h: drawH};

  const imgData = ctx.createImageData(cols, rows);
  const d = imgData.data;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const p = grid[r][c];
      const [cr, cg, cb] = probToColor(p);
      const imgRow = rows - 1 - r;
      const idx = (imgRow * cols + c) * 4;
      d[idx] = cr; d[idx+1] = cg; d[idx+2] = cb; d[idx+3] = 255;
    }
  }

  const offscreen = new OffscreenCanvas(cols, rows);
  const offCtx = offscreen.getContext('2d');
  offCtx.putImageData(imgData, 0, 0);

  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(offscreen, ox, oy, drawW, drawH);

  // Traversability overlay
  if (mapData.traversable) {
    const travCanvas = new OffscreenCanvas(cols, rows);
    const travCtx = travCanvas.getContext('2d');
    const travImg = travCtx.createImageData(cols, rows);
    const td = travImg.data;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const imgRow = rows - 1 - r;
        const idx = (imgRow * cols + c) * 4;
        if (mapData.traversable[r][c]) {
          td[idx] = 52; td[idx+1] = 152; td[idx+2] = 219; td[idx+3] = 50;
        }
      }
    }
    travCtx.putImageData(travImg, 0, 0);
    ctx.drawImage(travCanvas, ox, oy, drawW, drawH);
  }

  // Axes
  ctx.fillStyle = '#555';
  ctx.font = '11px monospace';
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 0.5;

  ctx.textAlign = 'center';
  const nTicks = 5;
  for (let i = 0; i <= nTicks; i++) {
    const val = xmin + worldW * i / nTicks;
    const px = ox + drawW * i / nTicks;
    ctx.fillText(val.toFixed(0), px, oy + drawH + 16);
    ctx.beginPath(); ctx.moveTo(px, oy); ctx.lineTo(px, oy + drawH); ctx.stroke();
  }
  ctx.textAlign = 'right';
  for (let i = 0; i <= nTicks; i++) {
    const val = ymin + worldH * i / nTicks;
    const py = oy + drawH - drawH * i / nTicks;
    ctx.fillText(val.toFixed(0), ox - 4, py + 4);
    ctx.beginPath(); ctx.moveTo(ox, py); ctx.lineTo(ox + drawW, py); ctx.stroke();
  }

  // Path
  if (path.length > 1) {
    ctx.strokeStyle = 'rgba(255, 200, 80, 0.6)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    const [px0, py0] = w2c(path[0][0], path[0][1]);
    ctx.moveTo(px0, py0);
    for (let i = 1; i < path.length; i++) {
      const [px, py] = w2c(path[i][0], path[i][1]);
      ctx.lineTo(px, py);
    }
    ctx.stroke();

    ctx.fillStyle = 'rgba(255, 200, 80, 0.9)';
    for (const pt of path) {
      const [px, py] = w2c(pt[0], pt[1]);
      ctx.beginPath(); ctx.arc(px, py, 3, 0, Math.PI * 2); ctx.fill();
    }
  }

  // Planned
  if (planned.length > 1) {
    ctx.strokeStyle = 'rgba(165, 94, 234, 0.7)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 4]);
    ctx.beginPath();
    const [pp0, pp1] = w2c(planned[0][0], planned[0][1]);
    ctx.moveTo(pp0, pp1);
    for (let i = 1; i < planned.length; i++) {
      const [px, py] = w2c(planned[i][0], planned[i][1]);
      ctx.lineTo(px, py);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = 'rgba(165, 94, 234, 0.9)';
    for (const pt of planned) {
      const [px, py] = w2c(pt[0], pt[1]);
      ctx.beginPath(); ctx.arc(px, py, 3.5, 0, Math.PI * 2); ctx.fill();
    }
  }

  // ICP Vectors
  for (const c of icpCorr) {
    const [fx, fy] = w2c(c.from[0], c.from[1]);
    const [tx, ty] = w2c(c.to[0], c.to[1]);
    const len = Math.hypot(tx - fx, ty - fy);
    if (len < 2) continue;
    ctx.strokeStyle = 'rgba(252, 92, 101, 0.7)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(fx, fy); ctx.lineTo(tx, ty); ctx.stroke();
    const angle = Math.atan2(ty - fy, tx - fx);
    ctx.fillStyle = 'rgba(252, 92, 101, 0.7)';
    ctx.beginPath();
    ctx.moveTo(tx, ty);
    ctx.lineTo(tx - 6 * Math.cos(angle - 0.5), ty - 6 * Math.sin(angle - 0.5));
    ctx.lineTo(tx - 6 * Math.cos(angle + 0.5), ty - 6 * Math.sin(angle + 0.5));
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle = 'rgba(252, 92, 101, 0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(fx, fy, 3, 0, Math.PI * 2); ctx.stroke();
  }

  // Robot
  const [rx, ry] = w2c(pose[0], pose[1]);
  const heading = pose[2] * Math.PI / 180;
  const sz = 12;
  ctx.save();
  ctx.translate(rx, ry);
  ctx.rotate(-heading);
  ctx.beginPath(); ctx.moveTo(sz, 0); ctx.lineTo(-sz * 0.7, -sz * 0.55);
  ctx.lineTo(-sz * 0.3, 0); ctx.lineTo(-sz * 0.7, sz * 0.55); ctx.closePath();
  ctx.fillStyle = '#e74c3c'; ctx.fill(); ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1.5; ctx.stroke();
  ctx.restore();

  // Target
  if (target) {
    const [tx, ty] = w2c(target[0], target[1]);
    ctx.strokeStyle = '#4ecca3';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(tx-8, ty); ctx.lineTo(tx+8, ty); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(tx, ty-8); ctx.lineTo(tx, ty+8); ctx.stroke();
    ctx.beginPath(); ctx.arc(tx, ty, 5, 0, Math.PI*2); ctx.stroke();
  }

  // Frontiers
  for (const f of frontiers) {
    ctx.fillStyle = 'rgba(253, 121, 168, 0.5)';
    for (const cell of f.cells) {
      const [fx, fy] = w2c(cell[0], cell[1]);
      ctx.fillRect(fx - 1.5, fy - 1.5, 3, 3);
    }
    const [cx, cy] = w2c(f.centroid[0], f.centroid[1]);
    ctx.fillStyle = '#fd79a8';
    ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.7)'; ctx.lineWidth = 1; ctx.stroke();
    ctx.fillStyle = '#fff';
    ctx.font = '9px monospace'; ctx.textAlign = 'left';
    ctx.fillText(f.size, cx + 6, cy + 3);
  }

  // Explore Goal
  if (exploreGoal) {
    const [ex, ey] = w2c(exploreGoal[0], exploreGoal[1]);
    ctx.strokeStyle = '#66fcf1';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(ex-10, ey); ctx.lineTo(ex+10, ey); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ex, ey-10); ctx.lineTo(ex, ey+10); ctx.stroke();
    ctx.beginPath(); ctx.arc(ex, ey, 7, 0, Math.PI*2); ctx.stroke();
  }
}

function w2c(wx, wy) {
  if (!mapData || !mapLayout) return [0, 0];
  const [xmin, xmax, ymin, ymax] = mapData.bounds;
  const {ox, oy, w, h} = mapLayout;
  return [
    ox + ((wx - xmin) / (xmax - xmin)) * w,
    oy + ((ymax - wy) / (ymax - ymin)) * h,
  ];
}

draw();
poll();

function toggleExplore() {
  if (exploring) fetch('/api/explore/stop', { method: 'POST' });
  else fetch('/api/explore', { method: 'POST' });
}

// ‚îÄ‚îÄ Chart.js ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

let pidChart = null;
function drawPidCharts(pid) {
  const labels = pid.t.map(v => v.toFixed(2));
  const data = {
    labels,
    datasets: [
      { label: 'L PWM', data: pid.left_pwm, borderColor: '#45aaf2', borderWidth: 1.5, pointRadius: 0, yAxisID: 'yPWM' },
      { label: 'R PWM', data: pid.right_pwm, borderColor: '#f7b731', borderWidth: 1.5, pointRadius: 0, yAxisID: 'yPWM' },
      { label: 'Err ¬∞', data: pid.heading_error, borderColor: '#4ecca3', borderWidth: 1.5, pointRadius: 0, borderDash: [4, 2], yAxisID: 'yErr' },
    ],
  };

  const opts = {
    responsive: true, maintainAspectRatio: false, animation: false,
    interaction: { mode: 'index', intersect: false },
    plugins: {
      legend: { labels: { color: '#888', font: { size: 9 }, boxWidth: 8, padding: 4 } },
    },
    scales: {
      x: { ticks: { color: '#555', font: { size: 8 }, maxTicksLimit: 5 }, grid: { display:false } },
      yPWM: {
        type: 'linear', position: 'left', min: 0, max: 100,
        ticks: { color: '#45aaf2', font: { size: 8 } },
        grid: { color: 'rgba(255,255,255,0.05)' },
      },
      yErr: {
        type: 'linear', position: 'right',
        ticks: { color: '#4ecca3', font: { size: 8 } },
        grid: { drawOnChartArea: false },
      },
    },
  };

  if (pidChart) { pidChart.data = data; pidChart.update(); }
  else { pidChart = new Chart(document.getElementById('pid-chart'), { type: 'line', data, options: opts }); }
}
</script>
</body>
</html>
