<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RoboTrail</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: system-ui, sans-serif;
    background: #0f0f1a;
    color: #e0e0e0;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 16px;
    min-height: 100vh;
  }
  h1 {
    font-size: 1.5em;
    margin-bottom: 10px;
    color: #fff;
    letter-spacing: 1px;
  }
  #status {
    background: rgba(255,255,255,0.06);
    backdrop-filter: blur(8px);
    padding: 8px 20px;
    border-radius: 8px;
    margin-bottom: 14px;
    font-family: 'SF Mono', 'Fira Code', monospace;
    font-size: 0.85em;
    border: 1px solid rgba(255,255,255,0.08);
  }
  .s-idle { color: #4ecca3; }
  .s-moving { color: #f7b731; }
  .s-scanning { color: #45aaf2; }
  .s-error { color: #fc5c65; }
  #status .label { color: #888; }
  #status .val { color: #4ecca3; }

  .canvas-wrap {
    position: relative;
    border-radius: 6px;
    overflow: hidden;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  }
  canvas {
    display: block;
    cursor: crosshair;
  }
  /* Axis labels drawn on canvas, but we add a subtle info line below */
  #hint {
    font-size: 0.75em;
    color: #555;
    margin-top: 10px;
    font-style: italic;
  }
</style>
</head>
<body>

<h1>ðŸ¤– RoboTrail</h1>
<div id="status">
  <span class="label">State:</span> <span id="st" class="s-idle">--</span>
  &nbsp;Â·&nbsp;
  <span class="label">Pose:</span> <span id="pose" class="val">--</span>
  &nbsp;Â·&nbsp;
  <span id="msg" style="color:#777">--</span>
</div>
<div class="canvas-wrap">
  <canvas id="c" width="720" height="720"></canvas>
</div>
<div id="hint">click on map to move robot</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

let mapData = null;     // {grid, bounds, rows, cols, version}
let mapVersion = -1;    // track last fetched version
let pose = [0, 0, 0];
let target = null;
let state = 'IDLE';

// â”€â”€ Single unified poll â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

setInterval(poll, 1000);

function poll() {
  fetch('/api/state').then(r => r.json()).then(d => {
    state = d.state;
    pose = d.pose;
    target = d.target;

    // Update status bar
    const stEl = document.getElementById('st');
    stEl.textContent = d.state;
    stEl.className = 's-' + d.state.toLowerCase();
    document.getElementById('pose').textContent =
      `(${d.pose[0].toFixed(1)}, ${d.pose[1].toFixed(1)}, ${d.pose[2].toFixed(0)}Â°)`;
    document.getElementById('msg').textContent = d.message;

    // Fetch map only when version changes
    if (d.map_version !== mapVersion) {
      mapVersion = d.map_version;
      fetchMap();
    } else {
      draw(); // still redraw for target/pose overlay updates
    }
  }).catch(() => {});
}

function fetchMap() {
  fetch('/api/map').then(r => r.json()).then(d => {
    mapData = d;
    draw();
  }).catch(() => {});
}

// â”€â”€ Click to move â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

canvas.onclick = (e) => {
  if (state !== 'IDLE') return;
  if (!mapData) return;

  const rect = canvas.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;
  const [xmin, xmax, ymin, ymax] = mapData.bounds;

  // Map uses MARGIN for axis labels
  const mx = MARGIN, my = MARGIN;
  const mw = W - MARGIN * 2, mh = H - MARGIN * 2;

  // Only respond to clicks inside the map area
  if (px < mx || px > mx + mw || py < my || py > my + mh) return;

  const wx = xmin + ((px - mx) / mw) * (xmax - xmin);
  const wy = ymax - ((py - my) / mh) * (ymax - ymin);

  if (confirm(`Move to (${wx.toFixed(0)}, ${wy.toFixed(0)}) cm?`)) {
    fetch('/api/target', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({x: wx, y: wy})
    });
  }
};

// â”€â”€ Colormap â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// p=0 (free) â†’ light teal, p=0.5 (unknown) â†’ dark navy, p=1 (wall) â†’ bright orange

function probToColor(p) {
  if (p < 0.5) {
    // Free (0) â†’ Unknown (0.5):  light teal â†’ dark navy
    const t = p / 0.5; // 0..1
    return [
      lerp(220, 18, t),  // R
      lerp(245, 22, t),  // G
      lerp(240, 40, t),  // B
    ];
  } else {
    // Unknown (0.5) â†’ Occupied (1):  dark navy â†’ bright warm
    const t = (p - 0.5) / 0.5; // 0..1
    return [
      lerp(18, 255, t),   // R
      lerp(22, 120, t),   // G
      lerp(40, 50, t),    // B
    ];
  }
}

function lerp(a, b, t) { return Math.round(a + (b - a) * t); }

// â”€â”€ Drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const MARGIN = 40; // pixels for axis labels

function draw() {
  ctx.fillStyle = '#0f0f1a';
  ctx.fillRect(0, 0, W, H);

  if (!mapData) {
    ctx.fillStyle = '#444';
    ctx.font = '16px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('Waiting for map...', W/2, H/2);
    return;
  }

  const {grid, bounds, rows, cols} = mapData;
  const [xmin, xmax, ymin, ymax] = bounds;

  // Map drawing area (inside margins)
  const mx = MARGIN, my = MARGIN;
  const mw = W - MARGIN * 2, mh = H - MARGIN * 2;

  // Create ImageData for smooth rendering
  // We render at grid resolution, then scale to canvas
  const imgData = ctx.createImageData(cols, rows);
  const d = imgData.data;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const p = grid[r][c];
      const [cr_, cg, cb] = probToColor(p);
      // Flip row: grid row 0 = world bottom â†’ image row (rows-1)
      const imgRow = rows - 1 - r;
      const idx = (imgRow * cols + c) * 4;
      d[idx] = cr_;
      d[idx+1] = cg;
      d[idx+2] = cb;
      d[idx+3] = 255;
    }
  }

  // Draw to offscreen canvas at native resolution, then scale up smoothly
  const offscreen = new OffscreenCanvas(cols, rows);
  const offCtx = offscreen.getContext('2d');
  offCtx.putImageData(imgData, 0, 0);

  // Scale to map area with smooth interpolation
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  ctx.drawImage(offscreen, mx, my, mw, mh);

  // â”€â”€ Axis labels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ctx.fillStyle = '#666';
  ctx.font = '11px monospace';
  ctx.textAlign = 'center';

  // X axis (bottom)
  const xSteps = 5;
  for (let i = 0; i <= xSteps; i++) {
    const val = xmin + (xmax - xmin) * i / xSteps;
    const px = mx + mw * i / xSteps;
    ctx.fillText(val.toFixed(0), px, H - 8);
    // Tick
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath(); ctx.moveTo(px, my); ctx.lineTo(px, my + mh); ctx.stroke();
  }

  // Y axis (left)
  ctx.textAlign = 'right';
  for (let i = 0; i <= xSteps; i++) {
    const val = ymin + (ymax - ymin) * i / xSteps;
    const py = my + mh - mh * i / xSteps;
    ctx.fillText(val.toFixed(0), mx - 4, py + 4);
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath(); ctx.moveTo(mx, py); ctx.lineTo(mx + mw, py); ctx.stroke();
  }

  // Axis titles
  ctx.fillStyle = '#555';
  ctx.font = '12px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('X (cm)', W/2, H - 0);
  ctx.save();
  ctx.translate(10, H/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText('Y (cm)', 0, 0);
  ctx.restore();

  // â”€â”€ Robot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [rx, ry] = worldToCanvas(pose[0], pose[1], bounds, mx, my, mw, mh);
  const heading = pose[2] * Math.PI / 180;
  const sz = 12;

  ctx.save();
  ctx.translate(rx, ry);
  ctx.rotate(-heading); // negate for canvas coords
  ctx.beginPath();
  ctx.moveTo(sz, 0);
  ctx.lineTo(-sz * 0.7, -sz * 0.55);
  ctx.lineTo(-sz * 0.3, 0);
  ctx.lineTo(-sz * 0.7, sz * 0.55);
  ctx.closePath();
  ctx.fillStyle = '#e74c3c';
  ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  ctx.restore();

  // â”€â”€ Target â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (target) {
    const [tx, ty] = worldToCanvas(target[0], target[1], bounds, mx, my, mw, mh);
    // Crosshair
    ctx.strokeStyle = '#4ecca3';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(tx-8, ty); ctx.lineTo(tx+8, ty); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(tx, ty-8); ctx.lineTo(tx, ty+8); ctx.stroke();
    ctx.beginPath(); ctx.arc(tx, ty, 5, 0, Math.PI*2); ctx.stroke();
  }
}

function worldToCanvas(wx, wy, bounds, mx, my, mw, mh) {
  const [xmin, xmax, ymin, ymax] = bounds;
  const px = mx + ((wx - xmin) / (xmax - xmin)) * mw;
  const py = my + ((ymax - wy) / (ymax - ymin)) * mh;
  return [px, py];
}

// Initial
draw();
poll();
</script>
</body>
</html>
